<div style="
  font-family: 'Times New Roman', Times, serif;
  font-size: 14pt;
  line-height: 1.5;
">
<p align="center">
Министерство науки и высшего образования Российской Федерации  
Федеральное государственное автономное образовательное учреждение  
высшего образования  
</p>

<p align="center">
<b>«Уральский федеральный университет<br>
имени первого Президента России Б.Н. Ельцина»</b>
</p>

<p align="center">
Институт радиоэлектроники и информационных технологий – РтФ  
<br>
ШПиАО «Прикладной анализ данных»
</p>

<br>
<br>
<br>

<h2 align="center">ОТЧЕТ</h2>

<p align="center">
по лабораторной работе №1  
</p>

<p align="center">
<b>«Основы работы с Docker и PostgreSQL»</b>
</p>

<br>
<br>
<br>

<p align="center">
Преподаватель: Кузьмин Денис Иванович  
</p>

<p align="center">
Обучающийся группы РИМ–150950  
<br>
Козырин Дмитрий Алексеевич
</p>

<br>
<br>
<br>
<br>

<p align="center">
Екатеринбург  
<br>
2025
</p>

---

## 1. ЦЕЛЬ РАБОТЫ

Освоить фундаментальные концепции и базовые операции Docker: создание образов, запуск контейнеров, управление ими, работа с сетями и томами. На практике закрепить навыки, запустив изолированную базу данных PostgreSQL и подключившись к ней извне.

---

## 2. ЗАДАЧИ

1. Установить и проверить работу Docker
2. Изучить базовые команды Docker
3. Запустить контейнер с PostgreSQL в изолированном режиме
4. Запустить контейнер с pgAdmin и подключить его к контейнеру с БД через сеть Docker
5. Подключиться к БД из pgAdmin, создать схему и выполнить запросы
6. Обеспечить сохранность данных БД с помощью томов Docker
7. Создать конфигурацию docker-compose.yaml для управления контейнерами

---

## 3. ХОД ВЫПОЛНЕНИЯ РАБОТЫ

### Часть 0: Установка и проверка Docker

#### 3.0.1. Установка Docker Desktop

В рамках начального этапа работы был установлен Docker Desktop для Windows с официального сайта https://www.docker.com/products/docker-desktop/.

Для работы с docker compose на Linux (для WSL docker работает с запущенной основной системы - Windows) была произведена установка с официальной документации https://docs.docker.com/compose/install/linux/.

#### 3.0.2. Проверка установки

После установки Docker была выполнена проверка корректности установки через команды:

```bash
docker --version
docker-compose --version
```

<img width="986" height="701" alt="image" src="https://github.com/user-attachments/assets/51958c1c-6e94-4d38-896d-bbfa2c43f9bc" />


Эти команды выводят версии установленных компонентов Docker и подтверждают успешную установку.

#### 3.0.3. Запуск тестового контейнера

Для окончательной проверки работоспособности Docker был запущен тестовый контейнер hello-world:

```bash
docker run hello-world
```

Команда скачала тестовый образ и запустила его, выводя приветственное сообщение:

```
Hello from Docker!
This message shows that your installation appears to be working correctly.
```

Это подтвердило, что Docker работает правильно и готов к использованию.

---

### Часть 1: Базовые команды Docker. Работа с образами и контейнерами

#### 3.1.1. Просмотр информации о системе

Были изучены базовые команды для получения информации о Docker:

```bash
# Информация о системе Docker
docker info

# Список всех образов на локальной машине
docker images

# Список запущенных контейнеров
docker ps

# Список всех контейнеров (включая остановленные)
docker ps -a
```

Команда `docker info` показывает общую информацию о системе Docker: количество контейнеров, образов, версию, используемый драйвер хранилища и другие параметры.

Команда `docker images` выводит список всех локально доступных образов с указанием их размера, тега и ID.

Команды `docker ps` и `docker ps -a` показывают текущие и все контейнеры соответственно, включая их статус, используемые порты и имена.

<img width="1430" height="655" alt="image" src="https://github.com/user-attachments/assets/7276748e-d8f8-406b-8b2a-d9933f1adcc9" />

#### 3.1.2. Запуск контейнера Nginx

Для практического освоения работы с контейнерами был запущен простой веб-сервер Nginx:

```bash
docker run -d -p 8080:80 --name my_nginx nginx:alpine
```

Разбор параметров команды:
- `-d` (detach) — запускает контейнер в фоновом режиме
- `-p 8080:80` — выполняет проброс портов (порт 8080 хоста связывается с портом 80 контейнера)
- `--name my_nginx` — задает понятное имя контейнеру
- `nginx:alpine` — указывает имя образа и его тег (облегченная версия на базе Alpine Linux)

После запуска контейнера было выполнено тестирование работы веб-сервера:

```bash
# Проверка запущенных контейнеров
docker ps
```

Открыв в браузере адрес http://localhost:8080, можно увидеть стандартную стартовую страницу Nginx с надписью "Welcome to nginx!", что подтверждает корректную работу контейнера.

#### 3.1.3. Остановка и удаление контейнера

После завершения тестирования контейнер был остановлен и удален:

```bash
# Остановка контейнера
docker stop my_nginx

# Удаление контейнера
docker rm my_nginx
```

<img width="1431" height="665" alt="image" src="https://github.com/user-attachments/assets/740b9017-d10b-4d8d-8712-9deb045bdc44" />


Команда `docker stop` корректно завершает работу контейнера, а `docker rm` удаляет его из системы. Важно отметить, что удаление возможно только после остановки контейнера.

---

### Часть 2: Запуск PostgreSQL в контейнере

#### 3.2.1. Запуск контейнера с PostgreSQL

Был запущен контейнер с системой управления базами данных PostgreSQL версии 15:

```bash
docker run -d \
  --name my_postgres_db \
  -e POSTGRES_USER=postgres \
  -e POSTGRES_PASSWORD=postgres \
  -e POSTGRES_DB=testdb \
  -p 5432:5432 \
  postgres:15
```

Разбор параметров команды:
- `-d` — запуск в фоновом режиме
- `--name my_postgres_db` — имя контейнера
- `-e` — установка переменных окружения внутри контейнера:
  - `POSTGRES_USER=postgres` — имя пользователя БД
  - `POSTGRES_PASSWORD=postgres` — пароль пользователя
  - `POSTGRES_DB=testdb` — имя создаваемой базы данных
- `-p 5432:5432` — проброс портов для возможности подключения внешних систем к БД
- `postgres:15` — образ PostgreSQL версии 15

Переменные окружения `POSTGRES_*` необходимы для первоначальной настройки СУБД при создании контейнера.

#### 3.2.2. Проверка работы контейнера

Для проверки работоспособности контейнера PostgreSQL была выполнена команда:

```bash
docker ps
```

В списке запущенных контейнеров появилась запись о контейнере `my_postgres_db` со статусом "Up", что подтверждает его корректную работу и прослушивание порта 5432.

<img width="1919" height="947" alt="image" src="https://github.com/user-attachments/assets/5bde4a46-7f97-4598-87f8-116fc01abaa3" />


#### 3.2.3. Подключение к PostgreSQL через psql

Для проверки работы базы данных было выполнено подключение непосредственно из контейнера через утилиту psql:

```bash
docker exec -it my_postgres_db psql -U postgres -d testdb
```

Параметры команды:
- `-it` — интерактивный режим с псевдо-TTY (позволяет вводить команды в консоли)
- `psql -U postgres -d testdb` — подключение к БД testdb под пользователем postgres

После выполнения команды открывается интерактивная консоль PostgreSQL, где были выполнены тестовые SQL-запросы:

```sql
-- Создание таблицы
CREATE TABLE users (
    id SERIAL PRIMARY KEY,
    name VARCHAR(100),
    email VARCHAR(100)
);

-- Вставка данных
INSERT INTO users (name, email) VALUES 
    ('Alice', 'alice@example.com'),
    ('Bob', 'bob@example.com');

-- Проверка данных
SELECT * FROM users;
```

Результат выполнения запроса SELECT показал две созданные записи:

```
 id | name  |        email        
----+-------+---------------------
  1 | Alice | alice@example.com
  2 | Bob   | bob@example.com
(2 rows)
```

Это подтвердило корректную работу базы данных и возможность выполнения SQL-операций.

Для выхода из консоли psql была использована команда `\q`.


---

### Часть 3: Подключение к БД через pgAdmin из второго контейнера

#### 3.3.1. Создание Docker-сети

Контейнеры по умолчанию изолированы друг от друга. Чтобы они могли взаимодействовать по именам (а не по IP-адресам), необходимо создать общую сеть Docker:

```bash
docker network create my_network
```

Команда создает пользовательскую мостовую сеть (bridge network) с именем `my_network`. В этой сети контейнеры могут обращаться друг к другу по именам контейнеров.

#### 3.3.2. Подключение контейнера PostgreSQL к сети

Существующий контейнер с PostgreSQL был подключен к созданной сети:

```bash
docker network connect my_network my_postgres_db
```

Эта команда добавляет контейнер `my_postgres_db` в сеть `my_network`, делая его доступным для других контейнеров в этой сети.

#### 3.3.3. Запуск контейнера pgAdmin

pgAdmin — это веб-интерфейс для администрирования PostgreSQL. Контейнер с pgAdmin был запущен в той же сети:

```bash
docker run -d \
  --name my_pgadmin \
  --network my_network \
  -e PGADMIN_DEFAULT_EMAIL=admin@example.com \
  -e PGADMIN_DEFAULT_PASSWORD=admin \
  -p 8080:80 \
  dpage/pgadmin4
```

Параметры команды:
- `--network my_network` — ключевой параметр, помещающий контейнер в ту же сеть, что и БД
- `-e PGADMIN_DEFAULT_EMAIL` — email для входа в pgAdmin
- `-e PGADMIN_DEFAULT_PASSWORD` — пароль для входа
- `-p 8080:80` — проброс порта для доступа к веб-интерфейсу
- `dpage/pgadmin4` — официальный образ pgAdmin

#### 3.3.4. Настройка подключения в pgAdmin

После запуска контейнера pgAdmin была выполнена настройка подключения к базе данных:

1. Открыт веб-интерфейс pgAdmin по адресу http://localhost:8080
2. Выполнен вход с учетными данными:
   - Email: admin@example.com
   - Password: admin
3. Добавлен новый сервер через меню "Add New Server":
   - **General → Name**: Docker PostgreSQL (произвольное имя)
   - **Connection → Host name/address**: my_postgres_db (имя контейнера с БД!)
   - **Connection → Port**: 5432
   - **Connection → Username**: postgres
   - **Connection → Password**: postgres
4. Подключение сохранено

Подключение прошло успешно, что подтвердило корректную работу сети Docker и возможность взаимодействия контейнеров.

#### 3.3.5. Выполнение запросов через pgAdmin

Через Query Tool в pgAdmin был выполнен SQL-запрос для проверки данных:

```sql
SELECT * FROM users;
```

В результате была получена таблица users с данными, созданными ранее через консоль psql:

```
 id | name  |        email        
----+-------+---------------------
  1 | Alice | alice@example.com
  2 | Bob   | bob@example.com
```

Это подтвердило, что pgAdmin успешно подключился к базе данных PostgreSQL, работающей в отдельном контейнере, и может выполнять SQL-запросы.

<img width="1429" height="710" alt="image" src="https://github.com/user-attachments/assets/9718c7fe-b355-4fa9-8a46-5bf484982e36" />

---

### Часть 4: Сохранение данных с помощью Томов (Volumes)

#### 3.4.1. Проблема сохранности данных

По умолчанию все данные, создаваемые внутри контейнера, хранятся в его файловой системе. При удалении контейнера эти данные безвозвратно теряются. Для демонстрации этой проблемы был выполнен эксперимент:

```bash
# Остановка и удаление контейнера с БД
docker stop my_postgres_db
docker rm my_postgres_db
```

После удаления контейнера все таблицы и данные в базе данных были утеряны. Это неприемлемо для реальных приложений, где данные должны сохраняться независимо от жизненного цикла контейнера.

#### 3.4.2. Создание тома Docker

Для решения проблемы был создан именованный том Docker:

```bash
docker volume create postgres_data
```

Том Docker — это специальная область хранения данных, управляемая Docker, которая существует независимо от контейнеров. Тома позволяют:
- Сохранять данные после удаления контейнеров
- Обмениваться данными между контейнерами
- Делать резервные копии и восстанавливать данные

#### 3.4.3. Запуск PostgreSQL с подключенным томом

Контейнер PostgreSQL был запущен заново с подключением созданного тома:

```bash
docker run -d \
  --name my_postgres_db \
  --network my_network \
  -e POSTGRES_USER=postgres \
  -e POSTGRES_PASSWORD=postgres \
  -e POSTGRES_DB=testdb \
  -p 5432:5432 \
  -v postgres_data:/var/lib/postgresql/data \
  postgres:15
```

Ключевой параметр:
- `-v postgres_data:/var/lib/postgresql/data` — монтирует том `postgres_data` в директорию `/var/lib/postgresql/data` внутри контейнера, где PostgreSQL хранит все свои данные

Теперь все данные базы данных будут записываться в том `postgres_data`, а не в файловую систему контейнера.

#### 3.4.4. Проверка сохранности данных

Для проверки работы тома была выполнена следующая последовательность действий:

1. **Создание тестовых данных через pgAdmin:**

<img width="1427" height="572" alt="image" src="https://github.com/user-attachments/assets/a77d36ab-e959-45a8-b894-d1da3e1cdb96" />


2. **Остановка контейнеров:**

```bash
docker stop my_postgres_db
docker stop my_pgadmin
```

3. **Запуск контейнеров заново:**

```bash
# Запуск PostgreSQL с тем же томом
docker start my_postgres_db

# Запуск pgAdmin
docker start my_pgadmin
```

4. **Проверка сохранности данных:**


Результат показал, что все данные сохранились:

<img width="1429" height="710" alt="image" src="https://github.com/user-attachments/assets/bb08f705-b8ea-470f-86a5-aa4520bcb9ee" />

Это подтвердило, что механизм томов Docker обеспечивает постоянное хранение данных независимо от жизненного цикла контейнеров.

---

### Часть 5: Перенос конфигурации контейнеров в docker-compose.yaml

#### 3.5.1. Назначение Docker Compose

Docker Compose — это инструмент для определения и запуска многоконтейнерных приложений Docker. Вместо ручного запуска каждого контейнера с множеством параметров, можно описать всю конфигурацию в одном YAML-файле и управлять всеми сервисами единой командой.

Преимущества использования Docker Compose:
- Декларативное описание инфраструктуры
- Простота воспроизведения окружения
- Управление зависимостями между сервисами
- Версионирование конфигурации

#### 3.5.2. Создание docker-compose.yaml

Была создана конфигурация Docker Compose, объединяющая все настройки PostgreSQL и pgAdmin:

```yaml
version: '3.8'

services:
  postgres:
    image: postgres:15
    container_name: my_postgres_db
    environment:
      POSTGRES_USER: postgres
      POSTGRES_PASSWORD: postgres
      POSTGRES_DB: testdb
    ports:
      - "5432:5432"
    volumes:
      - postgres_data:/var/lib/postgresql/data
    networks:
      - my_network
    restart: unless-stopped

  pgadmin:
    image: dpage/pgadmin4
    container_name: my_pgadmin
    environment:
      PGADMIN_DEFAULT_EMAIL: admin@example.com
      PGADMIN_DEFAULT_PASSWORD: admin
    ports:
      - "8080:80"
    networks:
      - my_network
    depends_on:
      - postgres
    restart: unless-stopped

networks:
  my_network:
    driver: bridge

volumes:
  postgres_data:
    driver: local
```

#### 3.5.3. Описание конфигурации

**Секция services:**

Определяет два сервиса:

1. **postgres** — контейнер с PostgreSQL:
   - `image: postgres:15` — используемый образ
   - `container_name: my_postgres_db` — имя контейнера
   - `environment` — переменные окружения для настройки БД
   - `ports: "5432:5432"` — проброс портов
   - `volumes: postgres_data:/var/lib/postgresql/data` — подключение тома
   - `networks: my_network` — подключение к сети
   - `restart: unless-stopped` — автоматический перезапуск при сбое

2. **pgadmin** — контейнер с pgAdmin:
   - `image: dpage/pgadmin4` — используемый образ
   - `environment` — учетные данные для входа
   - `ports: "8080:80"` — проброс порта для веб-интерфейса
   - `depends_on: postgres` — зависимость от сервиса postgres (запуск после него)
   - `restart: unless-stopped` — автоматический перезапуск

**Секция networks:**

Определяет пользовательскую сеть `my_network` с драйвером `bridge` для взаимодействия контейнеров.

**Секция volumes:**

Определяет именованный том `postgres_data` с драйвером `local` для постоянного хранения данных.

#### 3.5.4. Работа с Docker Compose

После создания файла `docker-compose.yaml` можно управлять всей инфраструктурой с помощью простых команд:

```bash
# Запуск всех сервисов
docker-compose up -d

# Остановка всех сервисов
docker-compose down

# Просмотр логов
docker-compose logs

# Просмотр статуса сервисов
docker-compose ps

# Перезапуск сервиса
docker-compose restart postgres
```

Команда `docker-compose up -d` автоматически:
- Создает сеть my_network
- Создает том postgres_data
- Запускает контейнер postgres
- Запускает контейнер pgadmin (после postgres)

Команда `docker-compose down` останавливает и удаляет все контейнеры и сети, но сохраняет том с данными.

---

## 4. ОТВЕТЫ НА ВОПРОСЫ

### Вопрос 1: Что такое Docker?

Docker — это платформа для разработки, доставки и запуска приложений в изолированных контейнерах. Docker позволяет упаковать приложение со всеми его зависимостями (библиотеками, системными утилитами, кодом) в стандартизированный контейнер, который можно запустить на любой системе, где установлен Docker.

**Основные концепции Docker:**

1. **Контейнер** — легковесная, изолированная среда для запуска приложения. Контейнер включает все необходимое для работы приложения, но использует ядро хост-системы, что делает его значительно легче виртуальной машины.

2. **Образ (Image)** — шаблон только для чтения, содержащий инструкции для создания контейнера. Образ состоит из слоев файловой системы и метаданных.

3. **Dockerfile** — текстовый файл с инструкциями для создания образа.

4. **Docker Hub** — облачный реестр для хранения и распространения образов.

---

### Вопрос 2: Для чего нужны тома и сети Docker?

#### Тома Docker (Volumes)

**Назначение:**

Тома предназначены для постоянного хранения данных, которые должны существовать независимо от жизненного цикла контейнеров.

**Проблема без томов:**

По умолчанию все файлы, создаваемые внутри контейнера, хранятся в записываемом слое контейнера. Когда контейнер удаляется, все его данные теряются безвозвратно. Это неприемлемо для баз данных, файлов загрузок, логов и других важных данных.

**Решение с использованием томов:**

Тома Docker — это механизм для сохранения данных вне файловой системы контейнера. Данные в томе сохраняются даже после удаления контейнера.

#### Сети Docker (Networks)

**Назначение:**

Сети обеспечивают коммуникацию между контейнерами и изоляцию различных групп контейнеров.

**Проблема без пользовательских сетей:**

По умолчанию контейнеры изолированы и не могут взаимодействовать друг с другом по имени. Для подключения нужно использовать IP-адреса, которые могут меняться при перезапуске.

**Решение с использованием сетей:**

Пользовательские сети Docker позволяют контейнерам обращаться друг к другу по именам (DNS-резолюция), а также обеспечивают изоляцию групп контейнеров.

**Практическое применение в лабораторной работе:**

В данной работе сеть `my_network` позволила контейнеру pgAdmin обращаться к контейнеру PostgreSQL по имени `my_postgres_db` вместо использования IP-адреса, что упростило конфигурацию и сделало её более надежной.

Том `postgres_data` обеспечил сохранность данных базы данных после перезапуска и удаления контейнеров, что критически важно для реальных приложений.

---

### Вопрос 3: Как подключиться к контейнеру и выполнить в нём команды?

Для выполнения команд внутри работающего контейнера используется команда `docker exec`. Она позволяет запустить процесс внутри уже работающего контейнера.

#### Базовый синтаксис:

```bash
docker exec [OPTIONS] CONTAINER COMMAND [ARG...]
```

**Ключи команды:**

- `-i` (interactive): сохраняет открытым STDIN, позволяя вводить данные
- `-t` (tty): выделяет псевдо-терминал (TTY)
- `-it`: комбинация обоих ключей для полноценной интерактивной работы
- `-u` (user): выполнить команду от имени указанного пользователя
- `-e` (environment): установить переменные окружения
- `-w` (workdir): установить рабочую директорию

**Практические сценарии:**

1. **Отладка приложения:**
```bash
docker exec -it app_container /bin/bash
cd /app
cat logs/error.log
```

2. **Выполнение миграций БД:**
```bash
docker exec app_container python manage.py migrate
```

3. **Проверка конфигурации:**
```bash
docker exec nginx_container nginx -t
```

4. **Мониторинг процессов:**
```bash
docker exec my_container ps aux
docker exec my_container top
```

**Важные замечания:**

- Контейнер должен быть в состоянии "running" (запущен)
- После выхода из интерактивной сессии (exit или Ctrl+D) контейнер продолжает работать
- Команда выполняется в контексте контейнера с его файловой системой и переменными окружения
- Для выхода из интерактивной сессии без остановки контейнера используйте `Ctrl+P, Ctrl+Q`

---

### Вопрос 4: Для чего нужен pgAdmin?

pgAdmin — это мощный инструмент для администрирования и управления базами данных PostgreSQL с графическим веб-интерфейсом.

#### Основное назначение:

pgAdmin предоставляет удобный визуальный способ работы с PostgreSQL, избавляя от необходимости запоминать SQL-синтаксис и работать исключительно через командную строку.

#### Ключевые возможности:

**1. Управление серверами и базами данных:**

- Подключение к нескольким серверам PostgreSQL одновременно
- Создание, изменение и удаление баз данных
- Управление схемами, таблицами, представлениями
- Настройка параметров сервера и баз данных
- Мониторинг подключений и активности

**2. Работа с данными:**

- Визуальный редактор таблиц (просмотр, добавление, изменение, удаление записей)
- Query Tool — редактор SQL-запросов с подсветкой синтаксиса и автодополнением
- Импорт и экспорт данных в различных форматах (CSV, JSON, XML)
- Построение запросов через графический конструктор
- История выполненных запросов

**3. Управление объектами БД:**

- Создание и изменение таблиц через визуальный редактор
- Управление индексами для оптимизации производительности
- Настройка первичных и внешних ключей
- Создание и редактирование представлений (views)
- Управление хранимыми процедурами и функциями
- Настройка триггеров

**4. Администрирование пользователей:**

- Создание и удаление пользователей и ролей
- Настройка прав доступа (GRANT/REVOKE)
- Управление привилегиями на уровне БД, схем, таблиц
- Контроль безопасности доступа

**5. Резервное копирование и восстановление:**

- Создание резервных копий (backup) баз данных и отдельных таблиц
- Восстановление данных из резервных копий (restore)
- Планирование автоматических резервных копий
- Экспорт схемы БД

---


## 6. ВЫВОД

В рамках лабораторной работы были успешно освоены фундаментальные концепции и базовые операции Docker. Изучены ключевые команды для управления образами и контейнерами, принципы работы с сетями и томами Docker.

На практике была развернута изолированная среда из двух взаимодействующих контейнеров: PostgreSQL для хранения данных и pgAdmin для администрирования базы данных через веб-интерфейс. Контейнеры были объединены через пользовательскую Docker-сеть, что обеспечило их безопасное взаимодействие по именам.

Особое внимание было уделено механизму томов Docker, который гарантирует постоянное хранение данных независимо от жизненного цикла контейнеров. Была продемонстрирована важность использования томов для критичных данных, таких как базы данных.

Финальным этапом работы стало создание конфигурации Docker Compose, которая декларативно описывает всю инфраструктуру приложения и позволяет управлять множеством контейнеров единой командой. Это упрощает развертывание, масштабирование и сопровождение контейнеризованных приложений.

Полученные навыки являются фундаментальными для современной разработки и развертывания приложений. Docker позволяет создавать портативные, изолированные и легко воспроизводимые окружения, что критически важно для эффективной разработки, тестирования и эксплуатации программного обеспечения.

Практическое применение знаний подтверждено успешным запуском и взаимодействием контейнеров, выполнением SQL-операций через pgAdmin и демонстрацией сохранности данных с использованием томов Docker.

</div>

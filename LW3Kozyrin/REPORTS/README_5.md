<div style="
  font-family: 'Times New Roman', Times, serif;
  font-size: 14pt;
  line-height: 1.5;
">
<p align="center">
Министерство науки и высшего образования Российской Федерации  
Федеральное государственное автономное образовательное учреждение  
высшего образования  
</p>

<p align="center">
<b>«Уральский федеральный университет<br>
имени первого Президента России Б.Н. Ельцина»</b>
</p>

<p align="center">
Институт радиоэлектроники и информационных технологий – РтФ  
<br>
ШПиАО «Прикладной анализ данных»
</p>

<br>
<br>
<br>

<h2 align="center">ОТЧЕТ</h2>

<p align="center">
по лабораторной работе №5  
</p>

<p align="center">
<b>«Форматирование и линтинг проекта. Сборка образа проекта»</b>
</p>

<br>
<br>
<br>

<p align="center">
Преподаватель: Кузьмин Денис Иванович  
</p>

<p align="center">
Обучающийся группы РИМ–150950  
<br>
Козырин Дмитрий Алексеевич
</p>

<br>
<br>
<br>
<br>

<p align="center">
Екатеринбург  
<br>
2025
</p>



## Цель работы

Познакомиться со способами поддержки качества кода и сборки образа приложения.

## Описание задачи

1. Установить и настроить линтеры и форматеры (pre-commit, pylint, black, isort)
2. Настроить автоматическую проверку кода перед коммитом
3. Создать Dockerfile для сборки образа приложения
4. Настроить docker-compose для запуска приложения с базой данных
5. Ответить на теоретические вопросы

## Ход выполнения

### Шаг 1: Установка и настройка линтеров и форматеров

#### 1.1. Обновление requirements.txt

Добавлены инструменты для линтинга и форматирования:

    black>=24.1.0
    isort>=5.13.0
    pylint>=3.0.0
    pre-commit>=3.6.0

#### 1.2. Настройка pre-commit

Создан файл `.pre-commit-config.yaml` с конфигурацией хуков:

- **Black** - автоматическое форматирование Python кода
- **isort** - автоматическая сортировка импортов
- **Pylint** - статический анализатор кода
- **pre-commit-hooks** - дополнительные проверки (trailing whitespace, end of file, yaml, large files)

#### 1.3. Настройка Pylint

Создан файл `.pylintrc` с настройками:

- **init-hook** - добавление текущей директории в PYTHONPATH для правильного разрешения импортов
- **disable** - отключение некритичных проверок (missing-docstring, too-many-arguments и т.д.)
- **extension-pkg-whitelist** - белый список для C-расширений (pydantic)
- **generated-members** - динамически генерируемые члены для SQLAlchemy
- **ignore-paths** - игнорирование тестов и миграций
- **max-line-length** - максимальная длина строки 120 символов

#### 1.4. Настройка Black и isort

В файле `pyproject.toml` добавлены секции:

**Black:**
- line-length: 120
- target-version: Python 3.11
- exclude: venv, migrations, node_modules

**isort:**
- profile: black (совместимость с Black)
- line_length: 120
- known_first_party: app (наш проект)

### Шаг 2: Установка и запуск pre-commit

    # Установка зависимостей
    pip install -r requirements.txt
    
    # Установка git hooks
    pre-commit install
    
    # Запуск проверки всех файлов
    pre-commit run --all-files

### Скришот поднятых контейнеров и логов одного из них
<img width="1678" height="783" alt="Снимок экрана 2025-12-16 в 05 16 05" src="https://github.com/user-attachments/assets/0e1be792-9b21-419b-9cc4-d376890a1ede" />

После этого каждый коммит будет автоматически проверяться линтерами и форматерами.

### Шаг 3: Создание Dockerfile

Создан `Dockerfile` со следующей структурой:

1. **FROM python:3.11-slim** - базовый образ с Python 3.11
2. **ENV** - переменные окружения:
   - PYTHONUNBUFFERED=1 - отключение буферизации вывода
   - PYTHONDONTWRITEBYTECODE=1 - отключение создания .pyc файлов
3. **WORKDIR /app** - рабочая директория
4. **COPY requirements.txt** - копирование зависимостей
5. **RUN pip install** - установка зависимостей
6. **COPY . .** - копирование проекта
7. **RUN chmod +x entrypoint.sh** - установка прав на выполнение
8. **EXPOSE 8000** - открытие порта
9. **ENTRYPOINT** - запуск через entrypoint.sh

### Шаг 4: Создание entrypoint.sh

Создан скрипт `entrypoint.sh` для запуска приложения:

    #!/bin/bash
    set -e
    
    echo "Starting Litestar Application"
    
    # Ожидание готовности БД
    echo "Waiting for database to be ready..."
    sleep 5
    
    # Запуск приложения
    exec uvicorn app.main:app \
        --host ${HOST:-0.0.0.0} \
        --port ${PORT:-8000} \
        --reload \
        --log-level ${LOG_LEVEL:-info}

### Шаг 5: Создание docker-compose.yaml

Создан `docker-compose.yaml` с двумя сервисами:

#### Сервис db (PostgreSQL):
- Образ: postgres:15-alpine
- Переменные окружения: POSTGRES_USER, POSTGRES_PASSWORD, POSTGRES_DB
- Порт: 5432
- Volume: postgres_data для постоянного хранения
- Healthcheck: проверка готовности БД

#### Сервис app (приложение):
- Build: из текущей директории
- Переменные окружения: DATABASE_URL, HOST, PORT
- Порт: 8000
- Volumes: монтирование кода для hot-reload
- **depends_on**: зависимость от БД с условием service_healthy
- restart: unless-stopped

### Шаг 6: Создание .dockerignore

Создан файл `.dockerignore` для исключения ненужных файлов из образа:
- Python кэш и артефакты
- Виртуальные окружения
- IDE файлы
- Git репозиторий
- Тестовые артефакты
- Node.js зависимости

### Шаг 7: Запуск проекта

    # Сборка и запуск контейнеров
    docker compose up --build
    
    # Или в фоновом режиме
    docker compose up -d --build
    
    # Проверка работы
    curl http://localhost:8000/users
    
    # Остановка
    docker compose down
    
    # Остановка с удалением volumes
    docker compose down -v

## Структура проекта после выполнения ЛР5

    LW3Kozyrin/
    ├── .pre-commit-config.yaml    # Конфигурация pre-commit
    ├── .pylintrc                  # Конфигурация pylint
    ├── .dockerignore              # Исключения для Docker
    ├── .env.example               # Пример переменных окружения
    ├── Dockerfile                 # Инструкции сборки образа
    ├── docker-compose.yaml        # Оркестрация контейнеров
    ├── entrypoint.sh             # Скрипт запуска приложения
    ├── pyproject.toml            # Конфигурация black и isort
    ├── requirements.txt          # Python зависимости
    ├── app/                      # Код приложения
    ├── tests/                    # Тесты


## Ответы на вопросы

### 1. Что такое Docker-контейнер и чем он отличается от виртуальной машины?

**Docker-контейнер** - это изолированная среда выполнения приложения, которая содержит все необходимые зависимости, библиотеки и конфигурации.

**Отличия от виртуальной машины:**

| Характеристика | Docker-контейнер | Виртуальная машина |
|---------------|------------------|-------------------|
| **Изоляция** | На уровне процессов | На уровне аппаратуры |
| **ОС** | Использует ядро хост-системы | Полная копия ОС |
| **Размер** | МБ (мегабайты) | ГБ (гигабайты) |
| **Запуск** | Секунды | Минуты |
| **Производительность** | Почти нативная | Накладные расходы на виртуализацию |
| **Ресурсы** | Минимальные | Требуется выделение RAM, CPU |

**Преимущества Docker:**
- Быстрый запуск и остановка
- Меньший размер образов
- Легковесность и эффективность
- Портативность между средами
- Версионность и воспроизводимость

### 2. Как работает кеширование слоев в Docker и почему это важно?

**Механизм кеширования:**

Docker образы состоят из слоев, где каждый слой соответствует одной инструкции в Dockerfile. Docker кеширует результаты выполнения каждой инструкции.

**Принцип работы:**
1. При сборке образа Docker проверяет, изменился ли слой
2. Если слой не изменился, используется кешированная версия
3. Если слой изменился, пересобираются он и все последующие слои
4. Кеш инвалидируется при изменении содержимого

**Пример оптимизации:**

    #  Плохо - при изменении кода пересобираются зависимости
    COPY . .
    RUN pip install -r requirements.txt
    
    #  Хорошо - зависимости кешируются
    COPY requirements.txt .
    RUN pip install -r requirements.txt
    COPY . .

**Почему это важно:**
- **Скорость сборки**: повторные сборки занимают секунды вместо минут
- **Экономия трафика**: не нужно скачивать зависимости каждый раз
- **Эффективность CI/CD**: быстрое развертывание
- **Экономия дискового пространства**: общие слои используются несколькими образами

### 3. Что означает инструкция depends_on в docker-compose?

**depends_on** определяет порядок запуска сервисов и зависимости между ними.

**Базовый синтаксис:**

    services:
      app:
        depends_on:
          - db

**Доступные условия:**
- **service_started**: сервис запущен (по умолчанию)
- **service_healthy**: сервис прошел healthcheck
- **service_completed_successfully**: сервис завершился успешно

**В нашем проекте:**

    app:
      depends_on:
        db:
          condition: service_healthy  # Ждем готовности БД

Это гарантирует, что приложение запустится только после того, как PostgreSQL будет готов принимать соединения.

### 4. Почему миграции БД выполняются в entrypoint.sh, а не во время сборки образа?

**Причины выполнения миграций в entrypoint.sh:**

1. **Образ не зависит от БД**
   - Во время сборки образа БД может быть недоступна
   - Образ должен быть независимым и переносимым

2. **Разные окружения**
   - Один образ используется для dev, staging, production
   - Каждое окружение имеет свою БД
   - Миграции должны применяться к конкретной БД при запуске

3. **Безопасность**
   - Во время сборки нет доступа к production БД
   - Секреты подключения (пароли) не должны быть в образе

4. **Гибкость**
   - Можно откатить миграции
   - Можно пропустить миграции при необходимости
   - Контроль версии схемы БД

5. **Состояние**
   - Образ - stateless (без состояния)
   - БД - stateful (с состоянием)
   - Миграции изменяют состояние, поэтому выполняются при запуске

**Правильный подход:**

    # entrypoint.sh
    #!/bin/bash
    
    # Ожидание готовности БД
    wait-for-it db:5432
    
    # Выполнение миграций
    alembic upgrade head
    
    # Запуск приложения
    exec uvicorn app.main:app

### 5. Что произойдет, если миграции завершатся ошибкой при запуске контейнера?

**Последствия ошибки миграций:**

1. **С `set -e` в entrypoint.sh (наш случай):**
   
       set -e  # Прерывание при ошибке
   
   - Скрипт немедленно завершится
   - Контейнер остановится с ненулевым exit code
   - Приложение не запустится
   - Docker покажет контейнер как failed/exited

3. **Без `set -e`:**
   - Миграции упадут, но скрипт продолжит выполнение
   - Приложение запустится с неактуальной схемой БД
   - Возможны runtime ошибки при работе с БД


### 6. В чем разница между линтерами (flake8) и форматерами (black)?

**Линтеры (Linters)** - инструменты для статического анализа кода, которые **находят проблемы** и **предупреждают** о них.

**Форматеры (Formatters)** - инструменты, которые **автоматически исправляют** форматирование кода.

**Детальное сравнение:**

| Аспект | Линтеры (flake8, pylint) | Форматеры (black, isort) |
|--------|--------------------------|---------------------------|
| **Цель** | Найти ошибки и проблемы | Привести код к единому стилю |
| **Действие** | Анализирует и сообщает | Изменяет код автоматически |
| **Что проверяют** | Логические ошибки, баги, код-смелл | Отступы, пробелы, переносы строк |
| **Результат** | Список предупреждений/ошибок | Отформатированный код |
| **Гибкость** | Множество настроек | Минимум настроек (opinionated) |

**Примеры проверок линтера (pylint/flake8):**

    # Неиспользуемый импорт
    import os  # F401: unused import
    
    # Неопределенная переменная
    print(undefined_var)  # F821: undefined name
    
    # Слишком много аргументов
    def func(a, b, c, d, e, f, g, h):  # R0913: too many arguments
        pass
    
    # Слишком сложная функция
    def complex_function():  # C0901: too complex
        # 50+ строк кода с множеством if/else
        pass
    
    # Потенциальная ошибка
    if x = 5:  # E0001: invalid syntax
        pass

**Примеры работы форматера (black):**

    # ДО форматирования
    def long_function(arg1,arg2,arg3,arg4,arg5):
        result=arg1+arg2+arg3
        return result
    
    x=[1,2,3,4,5,6,7,8,9,10]
    
    # ПОСЛЕ форматирования black
    def long_function(arg1, arg2, arg3, arg4, arg5):
        result = arg1 + arg2 + arg3
        return result
    
    
    x = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]

**Пример работы isort:**

    # ДО сортировки
    from app.models import User
    import os
    from typing import List
    import sys
    from app.schemas import UserSchema
    
    # ПОСЛЕ сортировки isort
    import os
    import sys
    from typing import List
    
    from app.models import User
    from app.schemas import UserSchema

**Комбинированное использование:**

    # .pre-commit-config.yaml
    repos:
      # Сначала форматируем
      - repo: https://github.com/psf/black
        hooks:
          - id: black
      
      - repo: https://github.com/PyCQA/isort
        hooks:
          - id: isort
      
      # Потом проверяем линтером
      - repo: https://github.com/PyCQA/pylint
        hooks:
          - id: pylint

**Почему используются вместе:**
1. Форматеры обеспечивают единый стиль
2. Линтеры находят логические проблемы
3. Форматеры = автоматизация, линтеры = контроль качества
4. Вместе создают чистый и надежный код

### 7. Как pre-commit хуки помогают в разработке?

**Pre-commit хуки** - это автоматические проверки, которые выполняются перед каждым коммитом в Git.

**Механизм работы:**

1. Разработчик выполняет `git commit`
2. Pre-commit автоматически запускает настроенные хуки
3. Хуки проверяют/форматируют измененные файлы
4. Если проверки прошли успешно - коммит создается
5. Если есть ошибки - коммит блокируется

**Преимущества для разработки:**

**1. Автоматизация качества кода:**

    # Без pre-commit (ручной процесс)
    black app/
    isort app/
    pylint app/
    git add .
    git commit -m "fix: update user model"
    
    # С pre-commit (автоматически)
    git commit -m "fix: update user model"
    # → black, isort, pylint запускаются автоматически

**2. Предотвращение проблем:**
- Блокирует коммиты с ошибками линтера
- Предотвращает коммит больших файлов
- Проверяет корректность YAML/JSON
- Удаляет trailing whitespace

**3. Единый стандарт в команде:**
- Все разработчики используют одни правила
- Нет споров о стиле кода в code review
- Автоматическое форматирование при коммите

**4. Ранее обнаружение проблем:**
- Ошибки находятся до попадания в репозиторий
- Не нужно исправлять в CI/CD
- Экономия времени на code review

**5. Образовательный эффект:**
- Разработчики видят свои ошибки сразу
- Учатся писать чистый код
- Понимают best practices

**Настройка в проекте:**

    # .pre-commit-config.yaml
    repos:
      # Форматирование
      - repo: https://github.com/psf/black
        rev: 24.1.1
        hooks:
          - id: black
    
      # Сортировка импортов
      - repo: https://github.com/PyCQA/isort
        rev: 5.13.2
        hooks:
          - id: isort
    
      # Линтинг
      - repo: https://github.com/PyCQA/pylint
        rev: v3.0.3
        hooks:
          - id: pylint
    
      # Общие проверки
      - repo: https://github.com/pre-commit/pre-commit-hooks
        rev: v4.5.0
        hooks:
          - id: trailing-whitespace  # Удаление пробелов в конце строк
          - id: end-of-file-fixer    # Пустая строка в конце файла
          - id: check-yaml           # Валидация YAML
          - id: check-added-large-files  # Блокировка больших файлов

**Команды pre-commit:**

# Установка хуков в Git
    pre-commit install

# Запуск на всех файлах
    pre-commit run --all-files

# Запуск конкретного хука
    pre-commit run black --all-files

# Обновление версий хуков
    pre-commit autoupdate

# Пропуск хуков (не рекомендуется)
    git commit --no-verify


**Типичные проблемы и решения:**

# Проблема: медленные хуки
# Решение: использовать параллельное выполнение

    default_stages: [commit, push]
    fail_fast: false

# Проблема: хуки падают на старом коде
# Решение: запускать только на измененных файлах

    files: ^(app|tests)/.*\.py$

# Проблема: разные версии инструментов
# Решение: зафиксировать версии в pre-commit-config

    rev: 24.1.1  # конкретная версия


**Интеграция с CI/CD:**

    # .github/workflows/lint.yml
    name: Lint
    on: [push, pull_request]
    jobs:
      pre-commit:
        runs-on: ubuntu-latest
        steps:
          - uses: actions/checkout@v3
          - uses: actions/setup-python@v4
          - uses: pre-commit/action@v3.0.0


## Выводы

В ходе выполнения лабораторной работы №5 были успешно решены следующие задачи:

1. **Настроены инструменты для поддержки качества кода:**
   - Установлен и настроен pre-commit для автоматической проверки кода перед коммитом
   - Настроен black для автоматического форматирования Python кода с максимальной длиной строки 120 символов
   - Настроен isort для сортировки импортов с профилем, совместимым с black
   - Настроен pylint для статического анализа кода с отключением некритичных проверок

2. **Создана инфраструктура для контейнеризации приложения:**
   - Написан Dockerfile с оптимальной структурой слоев для эффективного кеширования
   - Создан entrypoint.sh для инициализации и запуска приложения
   - Настроен docker-compose.yaml для оркестрации приложения и базы данных PostgreSQL
   - Добавлен .dockerignore для оптимизации размера образа

3. **Изучены теоретические основы:**
   - Понятие Docker-контейнеров и их отличия от виртуальных машин
   - Механизм кеширования слоев в Docker и его важность
   - Работа инструкции depends_on в docker-compose
   - Причины выполнения миграций в entrypoint.sh
   - Разница между линтерами и форматерами
   - Роль pre-commit хуков в процессе разработки

4. **Получены практические навыки:**
   - Работа с линтерами и форматерами для поддержки качества кода
   - Написание Dockerfile и оптимизация сборки образов
   - Использование docker-compose для локальной разработки
   - Настройка автоматических проверок перед коммитом

</div>






## Описание

В этой лабораторной работе реализована система планирования и выполнения фоновых задач с использованием **TaskIQ** для генерации ежедневных отчетов по заказам.

## Архитектура решения

### Компоненты системы

1. **TaskIQ Broker (RabbitMQ)** - брокер сообщений для очереди задач
2. **TaskIQ Worker** - воркер, который обрабатывает задачи из очереди
3. **TaskIQ Scheduler** - планировщик, который запускает задачи по расписанию
4. **PostgreSQL** - база данных для хранения заказов и отчетов
5. **Litestar API** - REST API для получения отчетов и ручного запуска задач

### Структура таблицы reports

```sql
CREATE TABLE reports (
    id SERIAL PRIMARY KEY,
    report_at DATE NOT NULL,           -- Дата отчета
    order_id INTEGER NOT NULL,         -- ID заказа
    count_product INTEGER NOT NULL,    -- Количество продуктов в заказе
    FOREIGN KEY (order_id) REFERENCES orders(id)
);
```

## Установка и запуск

### Запуск через Docker Compose (рекомендуется)

```bash
# 1. Создайте .env файл (или используйте значения по умолчанию)
cp .env.example .env

# 2. Запустите все сервисы
docker compose up --build

# Это запустит:
# - PostgreSQL (порт 5432)
# - RabbitMQ (порт 5672, UI: 15672)
# - Redis (порт 6379)
# - Litestar API (порт 8000)
# - TaskIQ Worker
# - TaskIQ Scheduler
```

## Использование

### 1. Автоматическая генерация отчетов

Планировщик автоматически генерирует отчеты каждый день в **00:00 UTC** за предыдущий день.

**Расписание в cron формате**: `0 0 * * *`

### 2. Ручная генерация отчета через API

```bash
# Запустить генерацию отчета за конкретную дату
curl -X POST "http://localhost:8000/report/generate?report_date=2024-01-15"

# Ответ:
{
  "status": "scheduled",
  "message": "Генерация отчета за 2024-01-15 запланирована",
  "task_id": "uuid-задачи"
}
```

### 3. Получение отчетов

```bash
# Получить отчеты за конкретную дату
curl "http://localhost:8000/report/?report_date=2024-01-15"

# Ответ:
[
  {
    "id": 1,
    "report_at": "2024-01-15",
    "order_id": 123,
    "count_product": 5
  },
  {
    "id": 2,
    "report_at": "2024-01-15",
    "order_id": 124,
    "count_product": 3
  }
]

# Получить все отчеты с пагинацией
curl "http://localhost:8000/report/all?page=1&count=10"
```

## Мониторинг

### RabbitMQ Management UI

Откройте в браузере: `http://localhost:15672`

- **Логин**: guest
- **Пароль**: guest

Здесь можно увидеть:
- Количество задач в очереди
- Статус worker'ов
- Историю выполненных задач

### Логи Docker

```bash
# Просмотр логов всех сервисов
docker compose logs -f

# Логи конкретного сервиса
docker compose logs -f taskiq-worker
docker compose logs -f taskiq-scheduler
docker compose logs -f app
```

## Принцип работы

### Поток генерации отчета

```
1. Scheduler (cron: 0 0 * * *)
   ↓
2. Создается задача generate_daily_report
   ↓
3. Задача отправляется в RabbitMQ очередь
   ↓
4. Worker получает задачу из очереди
   ↓
5. Worker выполняет задачу:
   - Находит все заказы за вчерашний день
   - Подсчитывает количество продуктов в каждом заказе
   - Сохраняет данные в таблицу reports
   ↓
6. Результат доступен через API /report/
```

### Формат задачи

```python
@broker.task(schedule=[{"cron": "0 0 * * *"}])
async def generate_daily_report():
    """
    Задача для генерации ежедневного отчета
    Запускается каждый день в 00:00 UTC
    """
    yesterday = date.today() - timedelta(days=1)
    
    # Получаем все заказы за вчерашний день
    # Для каждого заказа подсчитываем количество продуктов
    # Сохраняем в таблицу reports
    
    return {"status": "success", "date": str(yesterday)}
```

## Настройка расписания

### Изменение времени генерации отчетов

Отредактируйте файл `app/scheduler/taskiq_app.py`:

```python
# Текущее расписание: каждый день в 00:00 UTC
@broker.task(schedule=[{"cron": "0 0 * * *"}])

# Примеры других расписаний:

# Каждый день в 09:00 MSK (06:00 UTC)
@broker.task(schedule=[{"cron": "0 6 * * *"}])

# Каждый час
@broker.task(schedule=[{"cron": "0 * * * *"}])

# Каждые 30 минут
@broker.task(schedule=[{"cron": "*/30 * * * *"}])

# Каждый понедельник в 09:00
@broker.task(schedule=[{"cron": "0 9 * * 1"}])

# Каждый рабочий день в 09:00
@broker.task(schedule=[{"cron": "0 9 * * 1-5"}])
```

### Формат cron выражений

```
┌───────────── минуты (0 - 59)
│ ┌───────────── часы (0 - 23)
│ │ ┌───────────── день месяца (1 - 31)
│ │ │ ┌───────────── месяц (1 - 12)
│ │ │ │ ┌───────────── день недели (0 - 7) (0 и 7 = воскресенье)
│ │ │ │ │
* * * * *
```

Примеры:
- `0 0 * * *` - каждый день в полночь
- `0 */2 * * *` - каждые 2 часа
- `0 9-18 * * 1-5` - каждый час с 9 до 18 в рабочие дни
- `0 0 1,15 * *` - 1-го и 15-го числа каждого месяца

## Масштабирование

### Увеличение количества worker'ов

```bash
# В docker-compose.yaml можно масштабировать worker'ы:
docker compose up -d --scale taskiq-worker=3

# Это запустит 3 независимых worker'а, которые будут
# параллельно обрабатывать задачи из очереди
```

### Распределенная система

Для production окружения рекомендуется:

1. **Несколько worker'ов** на разных серверах для отказоустойчивости
2. **RabbitMQ кластер** для высокой доступности
3. **PostgreSQL репликация** для надежности данных
4. **Redis для кеширования** результатов задач

## Отладка и устранение проблем

### Задача не выполняется

1. Проверьте, что worker запущен:
   ```bash
   docker compose logs taskiq-worker
   ```

2. Проверьте очередь в RabbitMQ UI (localhost:15672)

3. Проверьте логи scheduler'а:
   ```bash
   docker compose logs taskiq-scheduler
   ```

### Ошибки подключения к БД

```bash
# Проверьте доступность PostgreSQL
docker compose ps db

# Проверьте переменную окружения DATABASE_URL
echo $DATABASE_URL
```

### Задачи накапливаются в очереди

Это означает, что worker не успевает обрабатывать задачи:

```bash
# Увеличьте количество worker'ов
docker compose up -d --scale taskiq-worker=3
```

## Полезные команды

```bash
# Перезапуск только TaskIQ компонентов
docker compose restart taskiq-worker taskiq-scheduler

# Просмотр статуса всех сервисов
docker compose ps

# Остановка всех сервисов
docker compose down

# Полная очистка (включая volumes)
docker compose down -v

# Просмотр логов в реальном времени
docker compose logs -f taskiq-worker taskiq-scheduler
```


# Ответы на вопросы

## 1. Что делает Брокер (Broker) в системе Taskiq?

**Брокер** в TaskIQ - это посредник для передачи сообщений между компонентами системы. Его основные функции:

### Функции брокера:

1. **Очередь задач**
   - Хранит задачи, ожидающие выполнения
   - Обеспечивает FIFO (First In, First Out) порядок обработки
   - Предотвращает потерю задач при сбоях

2. **Распределение нагрузки**
   - Распределяет задачи между несколькими worker'ами
   - Обеспечивает балансировку нагрузки
   - Позволяет горизонтальное масштабирование

3. **Гарантия доставки**
   - Подтверждает получение задач (ACK/NACK)
   - Повторяет доставку при неудаче
   - Хранит задачи до их успешного выполнения

4. **Асинхронность**
   - Позволяет отправлять задачи без ожидания их выполнения
   - Разделяет процессы создания и выполнения задач

---

## 2. Что делает Планировщик (Scheduler)?

**Планировщик (Scheduler)** - это компонент, который автоматически создает задачи по заданному расписанию.

### Функции планировщика:

1. **Расписание задач**
   - Запускает задачи по cron-выражениям
   - Поддерживает интервальное выполнение
   - Позволяет задавать сложные расписания

2. **Автоматизация**
   - Не требует ручного запуска
   - Работает в фоновом режиме
   - Создает задачи точно по времени

3. **Управление временными зонами**
   - Поддерживает offset для локального времени
   - Учитывает переход на летнее/зимнее время

---

## 3. Проблема перекрытия задач

### Постановка проблемы:

Задача `process_data` выполняется **10 секунд**, но запускается **каждые 5 секунд** по cron:

\`\`\`python
@broker.task(schedule=[{"cron": "*/5 * * * * *"}])  # Каждые 5 секунд
async def process_data():
    await asyncio.sleep(10)  # Выполняется 10 секунд
    # ... обработка данных
\`\`\`

### Проблемы в долгосрочной перспективе:

1. **Накопление задач в очереди**
   - Каждые 5 секунд добавляется новая задача
   - За 10 секунд добавится 2 задачи
   - Очередь будет расти линейно: +1 задача каждые 5 секунд

2. **Переполнение памяти**
   - Задачи накапливаются в RabbitMQ
   - Worker не успевает их обрабатывать
   - Возможно переполнение диска брокера

3. **Увеличение задержки**
   - Новые задачи ждут в очереди все дольше
   - Время от создания до выполнения растет
   - Система становится неотзывчивой

4. **Параллельное выполнение**
   - Если worker'ов несколько, задачи могут выполняться параллельно
   - Это может привести к race conditions
   - Возможны конфликты доступа к ресурсам

---

## 4. Настройка времени для MSK и подвох с UTC

### Требование:
Запускать задачу каждый будний день в **9:00 утра MSK** (московское время).

### Решение:

#### MSK = UTC+3 (зимнее время) или UTC+3 (постоянно с 2014 года)

```python
# 9:00 MSK = 6:00 UTC
@broker.task(schedule=[{
    "cron": "0 6 * * 1-5",  # Понедельник-Пятница в 6:00 UTC
}])
async def morning_task():
    """Задача выполняется в 9:00 MSK (6:00 UTC) по будням"""
    print(f"Задача запущена в {datetime.now()}")
```

### Формат cron выражения:

\`\`\`
0 6 * * 1-5
│ │ │ │ │
│ │ │ │ └── День недели: 1-5 (Пн-Пт)
│ │ │ └──── Месяц: * (любой)
│ │ └────── День месяца: * (любой)
│ └──────── Час: 6 (UTC)
└────────── Минута: 0
\`\`\`

### Подвох с UTC:

**Проблема 1: Переход на летнее/зимнее время**

В России с 2014 года **нет перехода на летнее время**, Москва постоянно UTC+3.
Но если сервер в другой стране или часовой пояс изменится:

```python
# ПЛОХО: Жестко указано 6:00 UTC
@broker.task(schedule=[{"cron": "0 6 * * 1-5"}])

# ХОРОШО: Указать timezone явно
from pytz import timezone

@broker.task(schedule=[{
    "cron": "0 9 * * 1-5",
    "timezone": timezone("Europe/Moscow")  # Явно указываем MSK
}])
```

**Проблема 2: Сервер работает в другом часовом поясе**

Если Docker контейнер или сервер настроен на другое время:

```bash
# Проверить timezone контейнера
docker exec litestar_taskiq_scheduler date +"%Z %z"

# Установить timezone для контейнера
# В docker-compose.yaml:
environment:
  - TZ=Europe/Moscow
```

**Важно:**
- Всегда указывайте `timezone` явно
- Используйте `pytz` для работы с часовыми поясами
- Тестируйте на разных серверах
- Документируйте ожидаемое время выполнения

---

## 5. Масштабирование и отказоустойчивость

### Сценарий: Количество задач резко выросло

#### Признаки проблемы:
- Очередь в RabbitMQ растет
- Задачи выполняются с задержкой
- Worker перегружен (CPU 100%)

#### Решение 1: Горизонтальное масштабирование worker'ов

```bash
# Увеличить количество worker'ов до 5
docker compose up -d --scale taskiq-worker=5

# Проверить статус
docker compose ps
```

**Как это работает:**
- Все worker'ы подключаются к одной очереди RabbitMQ
- RabbitMQ распределяет задачи между worker'ами (Round Robin)
- Каждая задача выполняется только одним worker'ом
- Если один worker занят, задача идет на следующий

#### Решение 2: Оптимизация задач

```python
# Плохо: Синхронные операции блокируют worker
@broker.task
async def slow_task():
    time.sleep(10)  # Блокирует event loop!
    result = requests.get("https://api.example.com")  # Блокирующий запрос
    return result

# Хорошо: Асинхронные операции
@broker.task
async def fast_task():
    await asyncio.sleep(10)  # Не блокирует
    async with aiohttp.ClientSession() as session:
        async with session.get("https://api.example.com") as response:
            return await response.json()
```

#### Решение 3: Приоритеты задач

```python
# Критичные задачи - высокий приоритет
@broker.task(priority=10)
async def critical_task():
    pass

# Обычные задачи - средний приоритет
@broker.task(priority=5)
async def normal_task():
    pass

# Фоновые задачи - низкий приоритет
@broker.task(priority=1)
async def background_task():
    pass
```

**Ключевые моменты:**
1. Несколько worker'ов для параллельной обработки
2. RabbitMQ кластер для отказоустойчивости
3. PostgreSQL репликация для надежности данных
4. Redis Sentinel для высокой доступности кеша
5. Резервный scheduler с проверкой через Redis lock
6. Мониторинг и алерты для быстрого реагирования

---

